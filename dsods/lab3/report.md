# Лабораторная работа №3

Вариант: `73892`

## Задание

Цель работы - настроить процедуру периодического резервного копирования базы данных, сконфигурированной в ходе выполнения лабораторной работы №2, а также разработать и отладить сценарии восстановления в случае сбоев.

Узел из предыдущей лабораторной работы используется в качестве основного. Новый узел используется в качестве резервного. Учётные данные для подключения к новому узлу выдаёт преподаватель. В сценариях восстановления необходимо использовать копию данных, полученную на первом этапе данной лабораторной работы.

### Этап 1. Резервное копирование

- Настроить резервное копирование с основного узла на резервный следующим образом:

  - Периодические полные копии с помощью SQL Dump. По расписанию (cron) раз в сутки, методом SQL Dump с сжатием. Созданные архивы должны сразу перемещаться на резервный хост, они не должны храниться на основной системе. Срок хранения архивов на резервной системе - 4 недели. По истечении срока хранения, старые архивы должны автоматически уничтожаться.

- Подсчитать, каков будет объем резервных копий спустя месяц работы системы, исходя из следующих условий:
  - Средний объем новых данных в БД за сутки: `950МБ`.
  - Средний объем измененных данных за сутки: `200МБ`.

- Проанализировать результаты.

### Этап 2. Потеря основного узла

Этот сценарий подразумевает полную недоступность основного узла. Необходимо восстановить работу СУБД на РЕЗЕРВНОМ узле, продемонстрировать успешный запуск СУБД и доступность данных.

### Этап 3. Повреждение файлов БД

Этот сценарий подразумевает потерю данных (например, в результате сбоя диска или файловой системы) при сохранении доступности основного узла. Необходимо выполнить полное восстановление данных из резервной копии и перезапустить СУБД на ОСНОВНОМ узле.

Ход работы:

- Симулировать сбой:
  - удалить с диска директорию любой таблицы со всем содержимым.
- Проверить работу СУБД, доступность данных, перезапустить СУБД, проанализировать результаты.
- Выполнить восстановление данных из резервной копии, учитывая следующее условие:
  - исходное расположение директории PGDATA недоступно - разместить данные в другой директории и скорректировать конфигурацию.
- Запустить СУБД, проверить работу и доступность данных, проанализировать результаты.

### Этап 4. Логическое повреждение данных

Этот сценарий подразумевает частичную потерю данных (в результате нежелательной или ошибочной операции) при сохранении доступности основного узла. Необходимо выполнить восстановление данных на ОСНОВНОМ узле следующим способом:

- Восстановление с использованием архивных WAL файлов. (СУБД должна работать в режиме архивирования WAL, потребуется задать параметры восстановления).

Ход работы:

- В каждую таблицу базы добавить 2-3 новые строки, зафиксировать результат.
- Зафиксировать время и симулировать ошибку:
  - в любой таблице с внешними ключами подменить значения ключей на случайные (INSERT, UPDATE)
- Продемонстрировать результат.
- Выполнить восстановление данных указанным способом.
- Продемонстрировать и проанализировать результат.

## Этап 1. Резервное копирование

### Настройка резервного копирования

#### На резервном хосте

Добавим скрипт (`~/store_backup_from_stdin.sh`) для сохранения архива из stdin:

```bash
#!/bin/bash

set -e

if [[ $# -ne 1 ]]; then
    echo "usage: $0 DATE"
    exit 1
fi

DATE=$1

BACKUP_DIR="$HOME/backups"
BACKUP_FILENAME="$DATE.bkp.gz"
BACKUP_FILEPATH="$BACKUP_DIR/$BACKUP_FILENAME"

mkdir -p $BACKUP_DIR

cat >$BACKUP_FILEPATH
```

А также скрипт для удаления старых архивов (`~/remove_old_backups.sh`):

```bash
#!/bin/bash

BACKUP_DIR=/var/db/postgres0/backups

if [[ ! -d "$BACKUP_DIR" ]]; then
    echo "Directory $DIRECTORY doesn't exist."
    exit 1
fi

find "$BACKUP_DIR" -type f -mtime +28 -exec rm {} \;

echo "Removed backups older than 4 weeks in $DIRECTORY."
```

И установим cron-таску для запуска этого скрипта раз в день:

```bash
(crontab -l; echo "0 0 * * * bash $HOME/remove_old_backups.sh") | crontab -
```

#### На основном хосте

Добавим скрипт (`~/backup.sh`) для создания и загрузки бэкапов на вспомогательный сервер:

```bash
#!/bin/bash

set -e

DATE=$(date "+%Y-%m-%d-%H-%M-%S")

echo "[$DATE] Starting backup..."

pg_dumpall -p 9253 -h /tmp -U postgres0 -w | gzip -c | ssh -i /var/db/postgres0/.ssh/id_rsa "$DSODS1_USER"@"$DSODS1_HOST" "bash ~/store_backup_from_stdin.sh $DATE"

echo "[$DATE] Backup created successfully"
```

И добавим для него cron-таску:

```bash
(crontab -l; echo "0 0 * * * bash $HOME/backup.sh") | crontab -
```

Далее, сгенерируем ssh-ключ и добавим его на резервную машину - чтобы была возможность подключаться без пароля:

```bash
ssh-keygen
ssh-copy-id -i ~/.ssh/id_rsa postgres0@pg139
```

Проверим, что все работает:

```bash
$ bash ./backup.sh 
[2025-04-21-10-01-34] Starting backup...
[2025-04-21-10-01-34] Backup created successfully
```

На втором сервере:

```bash
$ ls -lah backups/
total 14
drwxr-xr-x  2 postgres0 postgres    3B 21 апр.  10:01 .
drwxr-xr-x  4 postgres0 postgres   13B 21 апр.  10:01 ..
-rw-r--r--  1 postgres0 postgres  1,3K 21 апр.  10:01 2025-04-21-10-01-34.bkp.gz
```

### Подсчет объема резервных копий

```bash
$ ls -lah backups/2025-04-21-10-01-34.bkp.gz 
-rw-r--r--  1 postgres0 postgres  1,3K 21 апр.  10:01 backups/2025-04-21-10-01-34.bkp.gz
```

`start = 1.3 КБ`, `new_data_a_day = 950 МБ`, `updated_data_a_day = 200 МБ`, `N = 30 дней`

`result = start + (new_data_a_day * (N - 1)) / 2 * N = 1.3 КБ + (950 МБ * 29) / 2 * 30 = (28500 МБ) / 2 * 30 = 427500 МБ = 417.5 ГБ`

Объем внушительный, и пожалуй, даже чересчур. Вероятно, стоило бы сократить срок хранения полных бэкапов.

## Этап 2. Потеря основного узла

На резервном узле запустим кластер (для удобства - с теми же скриптами):

```bash
./init.sh 
./setup-conf.sh
pg_ctl start
```

И восстановим бэкап:

```bash
$ gunzip backups/2025-04-21-10-01-34.bkp.gz 
$ psql -p 9253 -d postgres -U postgres0 -w -X -f backups/2025-04-21-10-01-34.bkp
SET
SET
SET
<...>
```

Проверим:

```bash
$ psql -d longblueroad -p 9253 
psql (16.4)
Введите "help", чтобы получить справку.

longblueroad=# \dt
             Список отношений
 Схема | Имя |     Тип     | Владелец 
------------+--------+----------------+------------------
 public     | road   | таблица | postgres0
(1 строка)

longblueroad=# SELECT * FROM road;
 id | name | length 
----+------+--------
  1 | E95  |   3770
  2 | М-7 |    858
  3 | US 6 |    492
(3 строки)

longblueroad=# 
```

Таблицы и данные были успешно восстановлены.

## Этап 3. Повреждение файлов БД

```bash
$ psql -p 9253 -d longblueroad
psql (16.4)
Введите "help", чтобы получить справку.

longblueroad=# \dt
             Список отношений
 Схема | Имя |     Тип     | Владелец 
------------+--------+----------------+------------------
 public     | road   | таблица | postgres0
(1 строка)

longblueroad=# SELECT oid FROM pg_database WHERE datname = 'longblueroad';
  oid  
-------
 16385
(1 строка)

longblueroad=# SELECT oid FROM pg_class WHERE relname = 'road';
  oid  
-------
 16387
(1 строка)

longblueroad=#
```

Удалим:

```bash
rm uwo39/base/16385/16387
```

Проверим:

```bash
$ psql -p 9253 -d longblueroad
psql (16.4)
Введите "help", чтобы получить справку.

longblueroad=# \dt
             Список отношений
 Схема | Имя |     Тип     | Владелец 
------------+--------+----------------+------------------
 public     | road   | таблица | postgres0
(1 строка)

longblueroad=# SELECT * FROM road;
������:  �� ������� ������� ���� "base/16385/16387": ��� ������ ����� ��� ��������
```

Инстанс жив, но с данными беда - у нас нет доступа к таблице road. Перезапустим БД:

```bash
$ pg_ctl restart
ожидание завершения работы сервера.... готово
сервер остановлен
ожидание запуска сервера....2025-04-21 07:18:45.339 UTC [44617] СООБЩЕНИЕ:  передача вывода в протокол процессу сбора протоколов
2025-04-21 07:18:45.339 UTC [44617] ПОДСКАЗКА:  В дальнейшем протоколы будут выводиться в каталог "log".
 готово
сервер запущен
```

Проверим доступность:

```bash
$ psql -p 9253 -d longblueroad
psql (16.4)
Введите "help", чтобы получить справку.

longblueroad=# \dt
             Список отношений
 Схема | Имя |     Тип     | Владелец 
------------+--------+----------------+------------------
 public     | road   | таблица | postgres0
(1 строка)

longblueroad=# SELECT * FROM road;
������:  �� ������� ������� ���� "base/16385/16387": ��� ������ ����� ��� ��������
```

Ситуация не изменилась. Приступим к восстановлению. Перенаправим PGDATA на `uwo49`:

```bash
$ rm -rf amh13/
[postgres0@pg134 ~]$ export PGDATA="$HOME/uwo49"
[postgres0@pg134 ~]$ ./init.sh 
Файлы, относящиеся к этой СУБД, будут принадлежать пользователю "postgres0".
От его имени также будет запускаться процесс сервера.

Кластер баз данных будет инициализирован с локалью "ru_RU.KOI8-R".
Кодировка БД по умолчанию, выбранная в соответствии с настройками: "KOI8R".
Выбрана конфигурация текстового поиска по умолчанию "russian".

Контроль целостности страниц данных отключён.

исправление прав для существующего каталога /var/db/postgres0/uwo49... ок
создание подкаталогов... ок
выбирается реализация динамической разделяемой памяти... posix
выбирается значение max_connections по умолчанию... 100
выбирается значение shared_buffers по умолчанию... 128MB
выбирается часовой пояс по умолчанию... Europe/Moscow
создание конфигурационных файлов... ок
выполняется подготовительный скрипт... ок
выполняется заключительная инициализация... ок
сохранение данных на диске... ок

initdb: предупреждение: включение метода аутентификации "trust" для локальных подключений
initdb: подсказка: Другой метод можно выбрать, отредактировав pg_hba.conf или ещё раз запустив initdb с ключом -A, --auth-local или --auth-host.

Готово. Теперь вы можете запустить сервер баз данных:

    pg_ctl -D /var/db/postgres0/uwo49 -l файл_журнала start

$ ./setup-conf.sh 
$ pg_ctl start
ожидание запуска сервера....2025-04-21 07:25:56.265 UTC [45711] СООБЩЕНИЕ:  передача вывода в протокол процессу сбора протоколов
2025-04-21 07:25:56.265 UTC [45711] ПОДСКАЗКА:  В дальнейшем протоколы будут выводиться в каталог "log".
 готово
сервер запущен
$ scp postgres0@pg139:~/backups/2025-04-21-10-01-34.bkp.gz .
2025-04-21-10-01-34.bkp.gz                                                 100% 1385     1.5MB/s   00:00    
$ gunzip 2025-04-21-10-01-34.bkp.gz 
$ psql -p 9253 -d postgres -U postgres0 -w -X -f 2025-04-21-10-01-34.bkp 
SET
SET
SET
<...>
$ psql -p 9253 -d longblueroad
psql (16.4)
Введите "help", чтобы получить справку.

longblueroad=# \dt
             Список отношений
 Схема | Имя |     Тип     | Владелец 
------------+--------+----------------+------------------
 public     | road   | таблица | postgres0
(1 строка)

longblueroad=# SELECT * FROM road;
 id | name | length 
----+------+--------
  1 | E95  |   3770
  2 | М-7 |    858
  3 | US 6 |    492
(3 строки)

longblueroad=# 
```

Сработало, таблицы и данные БД снова доступны на момент создания резервной копии. Чтобы не возникало конфликтов, директория табличного пространства `amh13` была пересоздана.

## Этап 4. Логическое повреждение данных

Добавим в `postgresql.conf` следующие параметры:

```conf
wal_level = replica
archive_mode = on
archive_command = 'scp %p postgres0@pg139:~/wal_backups/%f'
```

И перезапустим кластер.

```bash
$ pg_ctl restart
ожидание завершения работы сервера.... готово
сервер остановлен
ожидание запуска сервера....2025-04-21 07:37:22.499 UTC [47098] СООБЩЕНИЕ:  передача вывода в протокол процессу сбора протоколов
2025-04-21 07:37:22.499 UTC [47098] ПОДСКАЗКА:  В дальнейшем протоколы будут выводиться в каталог "log".
 готово
сервер запущен
```

Добавим новые строки в таблицу:

```bash
$ psql -p 9253 -d longblueroad
psql (16.4)
Введите "help", чтобы получить справку.

longblueroad=# SELECT * FROM road;
 id | name | length 
----+------+--------
  1 | E95  |   3770
  2 | М-7 |    858
  3 | US 6 |    492
(3 строки)

longblueroad=# CREATE TABLE cafe (id SERIAL PRIMARY KEY, name TEXT NOT NULL, road_id INTEGER REFERENCES road(id));
CREATE TABLE
longblueroad=# INSERT INTO road (name, length) VALUES ('test1', 1000), ('test2', 2000), ('test3', 3000);
INSERT 0 3
longblueroad=# SELECT * FROM road;
 id | name  | length 
----+-------+--------
  1 | E95   |   3770
  2 | М-7  |    858
  3 | US 6  |    492
  4 | test1 |   1000
  5 | test2 |   2000
  6 | test3 |   3000
(6 строк)
longblueroad=# INSERT INTO cafe (name, road_id) VALUES ('cafe1', 4), ('cafe2', 5), ('cafe3', 6);
INSERT 0 3
longblueroad=# SELECT * FROM cafe;
 id | name  | road_id 
----+-------+---------
  1 | cafe1 |       4
  2 | cafe2 |       5
  3 | cafe3 |       6
(3 строки)
```

Фиксируем время и вносим ошибку:

```psql
longblueroad=# select now();
              now              
-------------------------------
 2025-04-21 07:58:13.323905+00
(1 строка)
longblueroad=# UPDATE cafe SET road_id = 1;
UPDATE 3
longblueroad=# SELECT * FROM cafe;
 id | name  | road_id 
----+-------+---------
  1 | cafe1 |       1
  2 | cafe2 |       1
  3 | cafe3 |       1
(3 строки)
```

Остановим сервер:

```bash
$ pg_ctl stop
ожидание завершения работы сервера.... готово
сервер остановлен
```

На основном сервере:

```bash
$ ls -lah uwo49/pg_wal/
total 55
drwx------   3 postgres0 postgres    6B 21 апр.  11:04 .
drwx------  20 postgres0 postgres   29B 21 апр.  11:04 ..
-rw-------   1 postgres0 postgres   16M 21 апр.  11:04 000000010000000000000003
-rw-------   1 postgres0 postgres   16M 21 апр.  11:04 000000010000000000000004
-rw-------   1 postgres0 postgres   16M 21 апр.  11:03 000000010000000000000005
drwx------   2 postgres0 postgres    3B 21 апр.  11:04 archive_status
```

На резервном:

```bash
$ ls -lah wal_backups/
total 3883
drwxr-xr-x  2 postgres0 postgres    5B 21 апр.  11:04 .
drwxr-xr-x  7 postgres0 postgres   18B 21 апр.  10:32 ..
-rw-------  1 postgres0 postgres   16M 21 апр.  10:54 000000010000000000000001
-rw-------  1 postgres0 postgres   16M 21 апр.  11:03 000000010000000000000002
-rw-------  1 postgres0 postgres   16M 21 апр.  11:04 000000010000000000000003
```

Скопируем WAL-файлы в другую директорию:

```bash
mkdir tmp
cp uwo49/pg_wal/* tmp/
```

Добавим в `postgresql.conf` следующие параметры:

```conf
restore_command = 'scp postgres0@pg139:~/wal_backups/%f %p'
recovery_target_time = '2025-04-21 07:58:13.323905+00'
recover_target_inclusive = off
```

Скопируем недостающие на рез.сервере сохраненные WAL-файлы:

```bash
cp ~/tmp/000000010000000000000004 .
cp ~/tmp/000000010000000000000005 .
```

Создадим файл-сигнал `recovery.signal`:

```bash
$ touch uwo49/recovery.signal
$ pg_ctl start
ожидание запуска сервера....2025-04-21 08:16:53.215 UTC [52407] СООБЩЕНИЕ:  передача вывода в протокол процессу сбора протоколов
2025-04-21 08:16:53.215 UTC [52407] ПОДСКАЗКА:  В дальнейшем протоколы будут выводиться в каталог "log".
 готово
сервер запущен
$ cat uwo49/log/postgresql-2025-04-21_081653.log 
2025-04-21 08:16:53.215 UTC [52407] СООБЩЕНИЕ:  запускается PostgreSQL 16.4 on amd64-portbld-freebsd14.1, compiled by FreeBSD clang version 18.1.6 (https://github.com/llvm/llvm-project.git llvmorg-18.1.6-0-g1118c2e05e67), 64-bit
2025-04-21 08:16:53.216 UTC [52407] СООБЩЕНИЕ:  для приёма подключений по адресу IPv6 "::1" открыт порт 9253
2025-04-21 08:16:53.216 UTC [52407] СООБЩЕНИЕ:  для приёма подключений по адресу IPv4 "127.0.0.1" открыт порт 9253
2025-04-21 08:16:53.226 UTC [52407] СООБЩЕНИЕ:  для приёма подключений открыт Unix-сокет "/tmp/.s.PGSQL.9253"
2025-04-21 08:16:53.244 UTC [52411] СООБЩЕНИЕ:  система БД была выключена: 2025-04-21 08:04:04 UTC
2025-04-21 08:16:53.245 UTC [52411] СООБЩЕНИЕ:  создаётся отсутствующий каталог WAL "pg_wal/archive_status"
scp: ~/wal_backups/00000002.history: No such file or directory
2025-04-21 08:16:53.520 UTC [52411] СООБЩЕНИЕ:  начинается восстановление архива
scp: ~/wal_backups/000000010000000000000004: No such file or directory
2025-04-21 08:16:53.768 UTC [52411] СООБЩЕНИЕ:  согласованное состояние восстановления достигнуто в позиции 0/40000A0
2025-04-21 08:16:53.768 UTC [52411] СООБЩЕНИЕ:  неверная длина записи в позиции 0/40000A0: ожидалось минимум 24, получено 0
2025-04-21 08:16:53.768 UTC [52411] СООБЩЕНИЕ:  данные REDO не требуются
2025-04-21 08:16:53.769 UTC [52407] СООБЩЕНИЕ:  система БД готова принимать подключения в режиме "только чтение"
scp: ~/wal_backups/000000010000000000000004: No such file or directory
scp: ~/wal_backups/00000002.history: No such file or directory
2025-04-21 08:16:55.218 UTC [52411] СООБЩЕНИЕ:  выбранный ID новой линии времени: 2
scp: ~/wal_backups/00000001.history: No such file or directory
2025-04-21 08:16:55.632 UTC [52411] СООБЩЕНИЕ:  восстановление архива завершено
2025-04-21 08:16:55.639 UTC [52409] СООБЩЕНИЕ:  начата контрольная точка: end-of-recovery immediate wait
2025-04-21 08:16:55.686 UTC [52409] СООБЩЕНИЕ:  контрольная точка завершена: записано буферов: 3 (0.0%); добавлено файлов WAL 0, удалено: 0, переработано: 0; запись=0.003 сек., синхр.=0.017 сек., всего=0.055 сек.; синхронизировано_файлов=2, самая_долгая_синхр.=0.009 сек., средняя=0.009 сек.; расстояние=0 kB, ожидалось=0 kB; lsn=0/40000A0, lsn redo=0/40000A0
2025-04-21 08:16:55.714 UTC [52407] СООБЩЕНИЕ:  система БД готова принимать подключения
```

Проверим данные:

```bash
$ psql -p 9253 -d longblueroad
psql (16.4)
Введите "help", чтобы получить справку.

longblueroad=# SELECT * FROM road;
 id | name  | length 
----+-------+--------
  1 | E95   |   3770
  2 | М-7  |    858
  3 | US 6  |    492
  4 | test1 |   1000
  5 | test2 |   2000
  6 | test3 |   3000
(6 строк)

longblueroad=# SELECT * FROM cafe;
 id | name  | road_id
----+-------+---------
  1 | cafe1 |       4
  2 | cafe2 |       5
  3 | cafe3 |       6
(3 строки)
```

И действительно, все вернулось на свое место.

## Заключение

В рамках данной лабораторной работы я попрактиковался в создании и восстановлении бэкапов (с помощью pg_dumpall), а также провел 3 сценария восстановления БД при ошибках.
