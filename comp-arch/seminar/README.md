# Доклад

## Общая информация

Компоненты и архитектура кластера Kubernetes.

Краткий экскурс в кубер, после - основная часть - рассмотрение архитектуры кластера kubernetes.

## Материалы

Запись доступна в журнале lab1 в репозитории курса.

Слайды - [здесь](slides.pdf) (Github чет не отрисовывает, лучше скачать)

## Вопрос для экзамена (№20 в списке камунити-вопросов)

Рекомендую глянуть сам доклад, вышло довольно бодро. Вдобавок советую глянуть документацию кубера, особенно [общий обзор](https://kubernetes.io/docs/concepts/overview/).

Местами мог оговориться, в случае сомнений - обращайтесь к документации.

### Вопрос

Объясните назначение и взаимосвязь компонентов кластера kubernetes (API server, etcd, Scheduler, Controller Manager, kubelet, kube-proxy, Container runtime).

### Перед ответом (для понимания происходящего)

Для начала стоит иметь представление о том, чем является `kubernetes` и для чего он нужен (дублирую [ссылку на доку](https://kubernetes.io/docs/concepts/overview/)).

Говоря про ответственность, существуют:

- **Администратор кластера** - занимается добавлением/удалением нод, изменением конфигурации кластера, настройкой политик, плагинов и т.д.
- **Инженер ("пользователь кластера")** - деплоит свои приложения, описывая их в манифестах (aka конфигах aka спеках). Чаще всего его не волнует, как устроен кластер - он просто деплоит свои приложения в рамках своего неймспейса, укладываясь в ресурсные ограничения.
- **Конечный пользователь сервисов** - никоим образом не знает про kubernetes, он лишь пользуется сервисом, который задеплоил в кластер инженер. Например, он заходит на сайт и получает свою страничку - при том не зная, что его запрос летит на одну из pod одной из node кластера kubernetes.

Вам точно должно быть знакомо понятие [контейнера](https://kubernetes.io/docs/concepts/containers/) (можно смело думать о них, как о Docker-контейнерах), [пода](https://kubernetes.io/docs/concepts/workloads/pods/) (можно считать kuber-овской оболочкой над контейнером).

Также важно понимать разницу между [архитектурной компонентой](https://kubernetes.io/docs/concepts/overview/components/) и [сущностью/объектом](https://kubernetes.io/docs/concepts/overview/working-with-objects/):

- **Компонент(а)** - это часть самого кластера, имеет физический смысл (api-сервер, программа, демон, БД).
- **Сущность/объект** - чаще всего абстрактное понятие, не имеющее физического представление. Объекты нужны для описания и спецификаций - на которые смотрят компоненты и соверашют соответствующие операции, чтобы привести эти описания в жизнь.

**TL;DR**: объект == конфиг/описание, компонент == программа, которая этот конфиг ест и на его основе что-то делает (все в рамках `kubernetes`!).

### Ответ

![arch.png](assets/arch.png)

Кластер состоит из следующих основных частей:

- `Control Plane` - "мозг" кластера
- `Node` (1 или более) - "рабочая машина".

#### Компоненты Control Plane

`API Server` - HTTP API-сервер кластера. Все взаимодействия остальных компонент происходят через него - для единообразия. Использует OpenAPI, формат данных - JSON. Помимо прочего, авторизация происходит в нем. В случае высокой нагрузки горизонтально масштабируется (т.е. поднимает дополнительные инстансы себя).

`etcd` - хранилище кластера, база данных. Key-value хранилище (как redis). Выбран как стандарт в силу отказоустойчивости (благодаря консенсусу Raft), надежности, и простоты с точки зрения формата данных. Все объекты, конфиги, информация хранится именно здесь.

`Scheduler` - компонент, занимающийся распределением подов по нодам. Это значит, что он регулярно смотрит на несозданные поды и не определенные никуда поды и выбирает, где бы их запустить, после - сохраняет свое решение в хранилище.

`Controller Manager` - менеджер контроллеров - запускает и менеджит набор так называемых контроллеров - "бесконечных циклов", которые следят за определенными типами объектов и совершают над ними действия. Можно считать, что буквально на каждый _тип объектов_ (pod, service, deployment, ...) есть собственный контроллер. Как было сказано в выступлении, он занимается тем, что приводит текущее состояние к желаемому: сейчас запущено 3 пода приложения AWESOME, а пользователь захотел 5 - контроллер увидел это желание и пошел его исполнять.

**TL;DR**:

- `API Server` - компонент, через который общаются все остальные компоненты.
- `etcd` - Key-Value-хранилище, БД кластера.
- `Scheduler` - выбирает, на какой ноде должен быть запущен конкретный под
- `Controller Manager` - менеджер контроллеров - бесконечных циклов, которые приводят текущее состояние к желаемому. На каждый вид объектов или концепций - свой контролер.

#### Компоненты Node

Все они так или иначе совершают действия, основываясь на спеках и изменениях в них - сами же они редко принимают самостоятельные решения. Вместе с тем, происходит и обратное общение: эти компоненты сообщают Control Plane о текущем состоянии, чтобы в "мозговом центре" была полная картина текущего состояния.

`Container Runtime` - в привычном понимании, движок контейнеров (`docker`) - создает, убивает, перезапускает контейнеры. Сам по себе он не принимает почти никаких решений. Можно спокойно воспринимать как обычный демон докера.

`kubelet` - агент на ноде, оперирующий подами. В том числе, он выступает в роли основного агента, "регистрирующего" ноду в кластере, а также следящим за состоянием этой самой ноды. Является прослойкой между `Container Runtime` и `Control Plane` - фактически, именно он, на основании `PodSpecs` (спецификаций подов, получаемым им от `Control Plane` через `API`) дает команды `Runtime` относительно того, что и с какими контейнерами нужно сделать.

`kube-proxy` - компонент на ноде, отвечающий за сеть, сетевые политики. Именно благодаря нему в кластере можно удобно обращаться из одной поды в другую посредством красивых DNS-имен (пример рассмотрен в докладе). Сетевые политики выстраиваются на основании спецификаций `Service`, внутренних `Ingress`/`Egress`, нод и подов.

**TL;DR**:

- `Container Runtime` - докер-демон (или другой контейнерный движок)
- `kubelet` - основной агент ноды. Регистрирует ноду в кластере, следит за ее состоянием, дает команды `Container Runtime` на основе спек `Pod`. "Материализатор" `Pod`-ов.
- `kube-proxy` - сетевой агент ноды, благодаря которому все поды со всех нод _могут_ (настраивается) иметь удобный сетевой доступ. "Материализатор" `Service`-ов.
